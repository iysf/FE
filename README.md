## CSS

[selector](https://github.com/iysf/blog/tree/master/CSS/selector)

[继承](https://github.com/iysf/blog/tree/master/CSS/继承)

[层叠](https://github.com/iysf/blog/tree/master/CSS/层叠/)

[单位](https://github.com/iysf/blog/tree/master/CSS/单位)

[字体](https://github.com/iysf/blog/tree/master/CSS/字体)

[文本阴影及对齐](https://github.com/iysf/blog/tree/master/CSS/文本阴影及对齐)

[浮动和定位](https://github.com/iysf/blog/tree/master/CSS/浮动和对齐)

[盒模型](https://github.com/iysf/blog/tree/master/CSS/盒模型)

[重绘](https://github.com/iysf/blog/tree/master/CSS/重绘)

[回流](https://github.com/iysf/blog/tree/master/CSS/回流)

## Vue

[M站 Vue 2.0 重构经验分享](https://github.com/iysf/blog/tree/master/Vue/M_Vue2.0)

## jQuery源码实现

[selector](https://github.com/iysf/blog/tree/master/jQuery/selector)

[jsonp](https://github.com/iysf/blog/blob/master/jQuery/ajax/html/jsonp.html)

## 单元测试

[karma](https://github.com/iysf/blog/blob/master/Jquery/ajax/html/jsonp.html)

full stack

## NodeJs

[爬虫](https://github.com/iysf/blog/blob/master/NodeJS/爬虫/)

<!-- ###### 基于Vue框架制作的功能
> [todoList](https://github.com/iysf/blog/tree/master/Vue/todoList)

> [星级评分](https://github.com/iysf/blog/tree/master/Vue/%E5%85%A8%E9%80%89%E5%8F%8D%E9%80%89)

> [分页](https://github.com/iysf/blog/tree/master/Vue/%E5%88%86%E9%A1%B5)

> [全选反选](https://github.com/iysf/blog/tree/master/Vue/%E5%85%A8%E9%80%89%E5%8F%8D%E9%80%89)

> [计算器](https://github.com/iysf/blog/tree/master/Vue/%E8%AE%A1%E7%AE%97%E5%99%A8) -->

<!-- > 模拟实现Vue原理
  * 双向绑定
  * v-for指令
  * v-html指令 -->

<!-- ### Vue-router

> 全局拦截 -->

<!-- ### Vuex

> 单向数据流

> actions

> mutations -->

<!-- ### Webpack

> 入口

> 出口

> plugin

> loader -->



<!-- ### Vue-cli

> 目录解析
  - build
    - dev-server.js
  - config
    - dev.env.js
    - index.js
    - prod.env.js
  - src
  - static -->

<!--  -->

<!-- ### Nodejs数据夹层
> 前端日志系统

> 引入Node层，在这一层把模板与数据进行合成，然后浏览器拿到的就是生成好的HTML了，但也不是所有HTML都是这么生成好的，还是会有一些内容等到了浏览器之后，再用js去加载和生成。
  - 需要搜索引擎带来流量的话 必须由服务器端渲染

> 性能优化

> 是否中间层一定要是node；python或者Go lang都可以，我觉得无所谓，只要是能正常做web项目的东西都可以，这个还是要看所在企业的技术积累方向，当然node做这块是有一些优势的，比如对前端人员的语言友好性，前后端模板的通用性等等，但这些都是细节，重点还是整体方案和流程。 -->

<!-- #### 算法：
* 排序
  1. [桶排序](https://github.com/iysf/legendary-JavaScript/blob/master/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E6%A1%B6%E6%8E%92%E5%BA%8F.html)
  2. [冒泡排序](https://github.com/iysf/legendary-JavaScript/blob/master/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.html)
  3. [快速排序](https://github.com/iysf/legendary-JavaScript/blob/master/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html)
  4. [归并排序](https://github.com/iysf/legendary-JavaScript/blob/master/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.html)
  5. [希尔排序](https://github.com/iysf/legendary-JavaScript/blob/master/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.html)
* 图
  1. [深度优先搜索]
  2. [广度优先搜索]
* 检索算法
  1. [顺序查找]
  2. [二分查找算法]
#### 前端监控：
* 捕获前端错误
  1. [前端代码异常](http://www.baidu.com)

#### 内部的api：
* 数组的[].push、[].pop、[].forEach等
* 函数的bind，call，apply等
* ES6的 new Set()等
#### 开发中的基础功能：
* 全选反选插件
* 分页插件
* 图片瀑布流
* 各种拦截: 请求拦截，跳转拦截，相应拦截，登录拦截等
* 聊天功能
* 评论功能
* 日期功能
* 模拟数据双向绑定原理
* Canvas游戏
#### 框架的底层原理：
* Vue的双向数据绑定、Vue:v-html，v-for、各种指令的封装等
* jquery的链式编程 选择器封装等
#### 面向对象：
* __proto__与prototype的关系
* 工厂模式
* 构造函数
* this原理
* 原型
* 封装_new()函数
#### 设计模式：
* 单例模式、访问者模式、观察者模式、桥接模式、工厂模式等
#### 作用域：
* 生命周期、编译原理、变量提升、运行环境等
#### HTTP协议：
* 通信过程、HTTP方法、协议格式、报文结构、首部字段、状态码
* 代理、网关、隧道
* SPDY、WebSocket、WebDAV
* 无状态(stateless)、301和302重定向的区别、缓存机制
* Web安全、HTTPS、SSL、证书认证、加密机制、Web攻击手段：Dos攻击、跨站点请求伪造（CSRF）、SQL注入、XSS攻击
* 在浏览器调试工具中 console中 直接$.ajax({}) 就可以访问后端的接口。 -->
