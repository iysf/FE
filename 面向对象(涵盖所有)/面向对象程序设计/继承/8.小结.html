<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>小结</title>
</head>
<body>

  <script type="text/javascript">
    function Person (name) {
      this.name = name
    }
    var ysf = new Person('ysf')

    console.log(ysf.__proto__ == Person.prototype)
    console.log(ysf)
    console.log(Person.prototype)
    // ECMAScript支持面向对象编程，但不使用类或者接口。对象可以在代码执行过程中创建和增强，因此具有动态性而非严格定义的实体。在没有类的情况下，可以采用下列模式创建对象。

    // 1.工厂模式: 使用简单函数创建对象，为对象添加属性和方法，然后返回对象，这个模式后来被构造函数模式取代。

    // 2.构造函数模式: 可以创建自定义引用类型，可以像创建内置对象实例一样使用 new 操作符。不过，构造函数模式也有缺点，即它的每个成员都无法得到复用，包括函数。由于函数不局限于任何对象(即与对象具有松散耦合的特点)，因此没有理由不在多个对象间共享函数。

    // 3.原型模式: 使用构造函数的prototype属性来指定那些应该共享的属性和方法。组合使用构造函数模式和原型模式时、使用构造函数定义实例属性，而原型定义共享的属性和方法。

    // JavaScript主要通过原型链实现继承。原型链的构建是通过将一个类型的实例赋值给另一个构造函数的原型实现的。这样，子类型就能够访问到超类型的所有属性和方法、这一点与类的继承很相似。

    // 原型链的问题是对象实例共享所有继承的属性和方法、因此不适宜单独使用。解决这个问题是技术是借用构造函数、即在子类型构造函数的内部调用超类型构造函数、这样就可以做到每个实例都具有自己的属性，同时还能保证只使用构造函数模式来定义类型。使用最多的继承模式是组合式继承，这种模式使用原型链继承共享的属性和方法，而通过借用构造函数继承实例属性。

    // 4.原型式继承: 无用

    // 5.寄生式继承: 基于某个对象或者某些信息创建一个对象、然后增强对象，最后返回对象。为了解决组合继承模式由于多次调用超类型构造函数而导致的低效率问题，可以将这个模式与组合继承一起使用。

    // 6.寄生组合式继承: 集寄生式继承和组合继承的优点于一身、是实现基于类型继承的最有效的方式。

  </script>


</body>
</html>
