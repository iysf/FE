<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	
	<script type="text/javascript">
		
		// 许多OO语言都支持两种继承方式：接口继承与实现继承。接口继承只继承方法签名。而实现继承则继承实际的方法。由于函数没有签名，在ECMAScript中无法实现接口继承。ECMAScript只支持实现继承，而且其实现继承主要是依靠原型链来实现的。

		// ECMAScript 中描述了原型链的概念，并将原型链作为实现继承的主要方法。其基本思路是利用原型让一个引用类型继承另一个引用类型的属性和方法。

		// 构造函数、原型和实例的关系。每个构造函数都有一个原型对象。原型对象都包含一个指向构造函数的指针。而实例都包含一个指向原型对象的内部指针。

		function _Person (a) {
			this.a = a
		}

		var a = new _Person()

		console.log("构造函数的原型:", _Person.prototype)
		console.log("原型指向构造函数:", _Person.prototype.constructor)
		console.log("实例包含指向构造函数原型的指针:", a.__proto__)


		// 假如让原型对象等于另一个类型的实例，显然，此时的原型对象将包含一个指向另一个原型的指针，相应的。另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例。那么上述关系依然成立。如此层层递进。就构成了实例与原型链的链条。这就是所谓原型链的基本概念。

		function superType () {
			this.property = true
		}

		superType.prototype.getSuperValue = function () {
			return this.property
		}

		function subType () {
			this.subProperty = false
		}

		// superType.prototype = new superType()
		
		// 继承了superType
		subType.prototype = new superType()

		subType.prototype.getSubValue = function () {
			return this.subProperty
		}

		// subType.prototype.
		var instance = new subType()


		console.log(instance.getSuperValue())

		// SuperType 和 SubType。每个类型分别有一个属性和一个方法。它们主要的区别是：SubType继承了SuperType。而继承是通过创建SuperType的实例，并将实例赋值给SubType.prototype实现的。实现的本质是重写原型对象。代之以一个新类型的实例。

	</script>

</body>
</html>