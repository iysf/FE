<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title>闭包</title>
</head>
<body>

	<script type="text/javascript">

		// 闭包是指有权访问另一个函数作用域中的变量的函数。


		// 内部函数的作用域链可以访问到外部函数的作用域链

		// 有关如何创建作用域链以及作用域链有什么作用的细节，对彻底理解闭包至关重要。当某个函数第一次调用的时候，会创建一个执行环境及相应的作用域链、
		//并把作用域链赋值给一个特殊的内部属性 即[[Scope]]。然后，使用this、arguments和其他命名参数的值来初始化函数的活动对象。

		//

		// 10.10日重写解读，
		// 当某个函数第一次被调用时，会创建一个执行环境 ( execution context )及相应的作用域链、并把作用域链赋值给一个特殊的内部属性 [[Scope]]。
		//然后，使用 this arguments和其他命名参数的值来初始化函数的活动对象 ( activation object )。但在作用域链中，
		// 外部函数的活动对象始终处于第二位。外部函数的外部函数的活动对象处于第三位、直至作为作用域链终点的全局执行环境、

		// 无论什么时候在函数中访问一个变量时，就会从作用域链中搜索具有相应名字的变量。一般来讲，当函数执行完毕后，局部活动对象就会被销毁。内存中仅仅保存全局作用域(全局执行环境的变量对象)。但是，闭包的情况又有所不同。

		// execution context => 执行环境 也称之为上下文

			 // 上下文这个词经常被乱用，主要有四种情况：

						// 1.当有人说“变量所处的上下文”时，实际指“词法环境”，或者我们常说的作用域，即规范中的Lexical Environment。
						// 2.当有人说“函数的上下文”时，实际指“函数的执行环境”，即规范中的Execution Context。
					  // 3.当有人说“call、apply和bind会改变函数执行的上下文”时，实际指“函数执行时的this”，即规范中的this binding。
						// 4.当有人说“你这段代码要结合上下文才能看出具体含义”时，此处的上下文就是我们日常生活中说的上下文。

		// Global variable object => 全局变量对象

		// activation object => 激活对象

		// Scope chain => 作用域链

		// 在另一个函数的内部定义的函数会将包含函数 (即外部函数) 的活动对象添加到它的作用域中，因此，在createComparisonFunction()函数内部定义的匿名函数的内部


		function createComparisonFunction () {

			return function () {

				console.log(111)

			}

		}

		//
	</script>


</body>
</html>
