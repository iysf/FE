<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>基本包装类型</title>
</head>
<body>
	
	<script type="text/javascript">
		
	// JavaScript有三个特殊的引用类型：Boolean、Number、String。实际上每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。

	var s1 = 'some text'
	var s2 = s1.substring(2)

	// 字符串是一个基本类型，却调用了substring()方法，并将返回的结果保存在s2中。我们知道，基本类型值不是对象，因此从逻辑上说它们也不应该拥有方法。其实为了让我们实现这种直观的操作，后台已经自动完成一系列的处理。后台自动完成了下列处理。

	// var s1 = new String('some text')
	// var s2 = s1.substring(2)
	// s1 = null

	// 经过此番处理，基本类型的字符串就变得和对象一样了。而且上边的这三个步骤也同样适用于布尔类型和数字类型。

	// 引用类型与基本包装类型的主要区别就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码执行的一瞬间，然后立即被销毁。

	var str = 'some text'
	var newStr = new String('some text')

	console.log("Str.Object:", str instanceof Object)
	console.log("newStr.Object:", newStr instanceof Object)

	console.log("Str.String:", str instanceof String)
	console.log("newStr.String:", newStr instanceof String)

	console.log(str)
	console.log(newStr)

	// 当然，可以显式地调用Boolean、Number 和 String 来创建基本包装类型的对象。不过，应该在绝对必要的情况下再这样做。因为这种做法很容易让人分不清自己到底是在操作引用类型还是基本类型的值。

	// Object

	var arr = new Object([1,2,3])
	var num = new Object(123)
	var str = new Object('abc')
	console.log("Array:", arr)
	console.log("Array:", arr instanceof Array)
	console.log("Number:", num)
	console.log("Number:", num instanceof Number)
	console.log("String:", str)
	console.log("String:", str instanceof String)

	var func = new Object(function(){
		console.log(123)
	})
	func()
	// Object工厂函数可以创造所有的类型，传入Array那么就返回Array的实例，返回function那么就返回function的实例。

	// 要注意的是，使用new 调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。
	</script>

</body>
</html>